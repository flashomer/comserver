#summary Code snippets for the Jedi Native Interface
#labels Phase-Deploy,Phase-Implementation,Phase-QA

= Introduction =

Here is a collection of code snippets from my jni experiments.


= Details =

You'll need a good handle on writing c++ and java to enjoy the jni to its full extent or find it practical for any particular task. 

==Starting the Red5 Server==
There are two ways to start the red5 server from c++. The obvious method of using the startup scripts is one, and creating it manually in the same way through the creation of a local JVM.

Method 2:
{{{
class Red5Server : public ICallbackCapable
{
public:
	JediNativeInterface * pJni;
	jmethodID mid ;
	jobject client; 

	jclass cls;

	Red5Server(JediNativeInterface * jni)
	{		
		client=0;

		this->pJni=jni;
		
	}
	void boot()
	{
		cls = (*pJni->getEnv()).FindClass( "org/red5/server/Bootstrap");
		
		mid = (*pJni->getEnv()).GetStaticMethodID( cls, "main","([Ljava/lang/String;)V");
		
		(*pJni->getEnv()).CallStaticVoidMethod( cls, mid,0);	


	}
}}}

==Stopping the Red5 Server==
The red5 server is done by creating a a new jvm and talking to it over an admin port. Lets cheat and use the script since this is a shut-down and we will not need to talk to the new jvm after it has done the task.

{{{
	void shutdown()
	{
		::ShellExecute(0,0,"red5-shutdown.bat",0,RED5_HOME,0);
		
	}
}}} 

==Initiate RPC Calls From Local Java VMs to C++ Jedi Native Interface==
Whether you need the JVM that you have created to call back on it's own threads, or if you need arbitrary JVMs to call your native process, it is supported on Windows through traditional JNI and named pipes.

On the native side, a class extends the ICallbackCapable base class. This reserves a channel number, currently supporting 1024 asynchronous  callback channels.

C++ settup
{{{
	JediNativeInterface * test= new JediNativeInterface();
	
	test->createJNI();

	Red5Server * server= new Red5Server(test);

	test->addCallbackHandler(server);//Add the native handler

	server->boot();
}}}

For simplicity, this prints out the request, and returns the RPC channel id that processed the call. 

C++ Hander Implementation. The data buffer contains the request and the results are placed into the 'results' buffer while returning the actual length of the data placed into the buffer.

{{{
	int processCall(char * data,char * results)
	{
		int i= this->getId();
		sprintf(results,"Processed by %d",i);
		
		printf("The request is %s\r\n",data);

		return (lstrlen(results))*sizeof(CHAR);
	}
}}}

On the Java side, you need the JediNativeCallback.dll in the directory where you are executing the c++ from, or in your system LD_PATH. And of course you need the JediNativeInterface.jar in the particular jvm's library.

The JNICallback class takes the channel id in the constructor, and the method signature is :

call(String callParameter, int rpcChannelNumber);

{{{

		JNICallback caller= new JNICallback(1);

		String ret = caller.call("foo", caller.getId());
		
		System.out.println("return was "+ ret);

}}}

The callback is synchronous and will block while c++ responds, or it will quickly timeout if the pipe server is not available. On the same token, the c++ process that calls the jvm can also be blocked by sleeping/waiting the Thread on the java side.




