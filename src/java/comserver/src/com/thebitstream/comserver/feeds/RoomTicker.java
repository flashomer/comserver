/*
 * COMSERVER Open Source Application Framework - http://www.thebitstream.com
 *
 * Copyright (c) 2009-2010 by Andy Shaules. All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation; either version 2.1 of the License, or (at your option) any later
 * version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with this library; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package com.thebitstream.comserver.feeds;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.red5.io.utils.ObjectMap;
import org.red5.server.net.rtmp.event.Notify;
import org.red5.server.net.rtmp.event.VideoData;

import com.thebitstream.comserver.feeds.SimpleFeedBase;
import com.thebitstream.comserver.nodes.IComserverNode;
import com.thebitstream.comserver.stream.IResourceSink;
import com.thebitstream.comserver.stream.util.InvocationFactory;


/**
 * Node data broadcaster. 
 * <p>Every resource stores a reference to all the Nodes that are currently subscribed.
 * The RoomTicker gets the list of nodes and broadcasts the node data.
 * It uses the periodic tick thread generated by the resource executor. 
 * Each Resource sink provides a 'courtesy tick' to the feeds. 
 * A more advanced feed should create it's own thread and ignore the ticker 'execute' method. 
 * The resource ticker interval is set in the Application super class and is used for all resources. Default is one tick per second.</p>
 * 
 * @author Andy Shaules
 * @version 1.0
 */
public class RoomTicker extends SimpleFeedBase{
	
	ArrayList<Object>joined=new ArrayList<Object>();
	
	ArrayList<Object>parted=new ArrayList<Object>();

	//This is a shared thread. 
	//If you need your own dedicated thread, create one.
	@Override
	public void execute(IResourceSink sink) 
	{
		synchronized(joined){
			
			ObjectMap<Object,Object> data=new ObjectMap<Object,Object>();
		
			data.put("feed", resourceSink.getStream().getPublishedName());	
			
			//Resource stores list of nodes.
			List<IComserverNode>subscribers= resourceSink.getSubscribers();
		
			ArrayList<Object>ret=new ArrayList<Object>();
				
			for(int i=0;i<subscribers.size();i++)
			{
				//Create array of node data.
				ret.add( subscribers.get(i).getNodeData());
			}
			data.put("players", ret);
			data.put("joined", joined);
			data.put("parted", parted);
			
			// create FLV invocation.
			
			// the flv tags here are the same tags that the action script codecs create. 
			// they do not have the full wrapper that is applied by the transcoder object;
			Map<String,VideoData> vData=new HashMap<String,VideoData>();
			
			// lets assume that this map contains up to n number of channels, 
			// and represents all the next frames 
			// that fall within up to a 100 millisecond window
			// from each channel. The smaller the window the better I imagine, 
			// to insure even spray of data accross the set.
			
			Iterator<String> channelCueable = vData.keySet().iterator();
			
			while(channelCueable.hasNext()){
				//assume file name is channel
				String channel = channelCueable.next();
				//same structure as tag as3 video codec.
				VideoData event = vData.get(channel);

				Map<Object,Object> params=new HashMap<Object,Object>();
				//this event goes to a Transcoder. 
				//private function onTag(sde:StreamDataEvent):void
				//using the channel names, feed tags to separate netstreams.
				params.put(channel, event);
				
				Notify invoke = InvocationFactory.createNotifyEvent("videoData", params);
				resourceSink.getStream().dispatchEvent(invoke);
			}
			
			
					
			
			parted.clear();
			joined.clear();
		}
	}

	@Override
	public void onClientAdded(IComserverNode connection) {
		synchronized(joined){
			joined.add(connection.getNodeId());
		}
	}

	@Override
	public void onClientRemoved(IComserverNode connection) {
		synchronized(joined){
			parted.add(connection.getNodeId());
		}
		
	}

}
